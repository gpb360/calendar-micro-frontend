import {
  require_react
} from "./chunk-PB3AIZ72.js";
import "./chunk-ROME4SDB.js";

// ../../node_modules/.pnpm/single-spa-react@6.0.1_@types+react-dom@18.3.0_@types+react@18.3.5_react@18.3.1/node_modules/single-spa-react/lib/esm/single-spa-react.js
function e(e2, t2) {
  var n2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    t2 && (o2 = o2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
    })), n2.push.apply(n2, o2);
  }
  return n2;
}
function t(t2) {
  for (var n2 = 1; n2 < arguments.length; n2++) {
    var r2 = null != arguments[n2] ? arguments[n2] : {};
    n2 % 2 ? e(Object(r2), true).forEach(function(e2) {
      o(t2, e2, r2[e2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(r2)) : e(Object(r2)).forEach(function(e2) {
      Object.defineProperty(t2, e2, Object.getOwnPropertyDescriptor(r2, e2));
    });
  }
  return t2;
}
function n(e2) {
  return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
    return typeof e3;
  } : function(e3) {
    return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
  })(e2);
}
function o(e2, t2, n2) {
  return t2 in e2 ? Object.defineProperty(e2, t2, { value: n2, enumerable: true, configurable: true, writable: true }) : e2[t2] = n2, e2;
}
function r(e2) {
  return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
    return typeof e3;
  } : function(e3) {
    return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
  })(e2);
}
function a(e2, t2) {
  var n2;
  if ("function" != typeof (n2 = t2.domElement ? function() {
    return t2.domElement;
  } : t2.domElementGetter ? t2.domElementGetter : e2.domElementGetter ? e2.domElementGetter : function(e3) {
    var t3 = e3.appName || e3.name;
    if (!t3)
      throw Error("single-spa's dom-element-getter-helpers was not given an application name as a prop, so it can't make a unique dom element container for the react application");
    var n3 = "single-spa-application:".concat(t3);
    return function() {
      var e4 = document.getElementById(n3);
      return e4 || ((e4 = document.createElement("div")).id = n3, document.body.appendChild(e4)), e4;
    };
  }(t2)))
    throw Error("single-spa's dom-element-getter-helpers was given an invalid domElementGetter for application or parcel '".concat(t2.name, "'. Expected a function, received ").concat(r(n2)));
  return function() {
    var e3 = n2(t2);
    if (!(e3 instanceof HTMLElement))
      throw Error("single-spa's dom-element-getter-helpers: domElementGetter returned an invalid dom element for application or parcel '".concat(t2.name, "'. Expected HTMLElement, received ").concat(r(e3)));
    return e3;
  };
}
var c = null;
try {
  c = require_react().createContext();
} catch (e2) {
}
var u = { React: null, ReactDOM: null, ReactDOMClient: null, rootComponent: null, loadRootComponent: null, errorBoundary: null, errorBoundaryClass: null, domElementGetter: null, parcelCanUpdate: true, suppressComponentDidCatchWarning: false, domElements: {}, renderResults: {}, updateResolves: {}, unmountResolves: {} };
function i(e2) {
  if ("object" !== n(e2))
    throw new Error("single-spa-react requires a configuration object");
  var o2, r2 = t(t({}, u), e2);
  if (!r2.React)
    throw new Error("single-spa-react must be passed opts.React");
  if (!r2.ReactDOM && !r2.ReactDOMClient)
    throw new Error("single-spa-react must be passed opts.ReactDOM or opts.ReactDOMClient");
  r2.renderType || (null !== (o2 = r2.ReactDOMClient) && void 0 !== o2 && o2.createRoot ? r2.renderType = "createRoot" : r2.renderType = "render");
  if (!r2.rootComponent && !r2.loadRootComponent)
    throw new Error("single-spa-react must be passed opts.rootComponent or opts.loadRootComponent");
  if (r2.errorBoundary && "function" != typeof r2.errorBoundary)
    throw Error("The errorBoundary opt for single-spa-react must either be omitted or be a function that returns React elements");
  !c && r2.React.createContext && (c = r2.React.createContext()), r2.SingleSpaRoot = function(e3) {
    function t2(e4) {
      t2.displayName = "SingleSpaRoot(".concat(e4.name, ")");
    }
    return t2.prototype = Object.create(e3.React.Component.prototype), t2.prototype.componentDidMount = function() {
      setTimeout(this.props.mountFinished);
    }, t2.prototype.componentWillUnmount = function() {
      setTimeout(this.props.unmountFinished);
    }, t2.prototype.render = function() {
      return setTimeout(this.props.updateFinished), this.props.children;
    }, t2;
  }(r2);
  var a2 = { bootstrap: s.bind(null, r2), mount: p.bind(null, r2), unmount: l.bind(null, r2) };
  return r2.parcelCanUpdate && (a2.update = m.bind(null, r2)), a2;
}
function s(e2, t2) {
  return e2.rootComponent ? Promise.resolve() : e2.loadRootComponent(t2).then(function(t3) {
    e2.rootComponent = t3;
  });
}
function p(e2, t2) {
  return new Promise(function(n2, o2) {
    e2.suppressComponentDidCatchWarning || !function(e3) {
      if (!(e3 && "string" == typeof e3.version && e3.version.indexOf(".") >= 0))
        return false;
      var t3 = e3.version.slice(0, e3.version.indexOf("."));
      try {
        return Number(t3) >= 16;
      } catch (e4) {
        return false;
      }
    }(e2.React) || e2.errorBoundary || e2.errorBoundaryClass || (e2.rootComponent.prototype ? e2.rootComponent.prototype.componentDidCatch || console.warn("single-spa-react: ".concat(t2.name || t2.appName || t2.childAppName, "'s rootComponent should implement componentDidCatch to avoid accidentally unmounting the entire single-spa application.")) : console.warn("single-spa-react: ".concat(t2.name || t2.appName || t2.childAppName, "'s rootComponent does not implement an error boundary.  If using a functional component, consider providing an opts.errorBoundary to singleSpaReact(opts).")));
    var r2 = y(e2, t2, function() {
      n2(this);
    }), c2 = a(e2, t2)(), u2 = function(e3) {
      var t3 = e3.reactDom, n3 = e3.renderType, o3 = e3.elementToRender, r3 = e3.domElement, a2 = t3[n3];
      if ("function" != typeof a2)
        throw new Error('renderType "'.concat(n3, '" did not return a function.'));
      switch (n3) {
        case "createRoot":
        case "unstable_createRoot":
        case "createBlockingRoot":
        case "unstable_createBlockingRoot":
          var c3 = a2(r3);
          return c3.render(o3), c3;
        case "hydrateRoot":
          return a2(r3, o3);
        case "hydrate":
        default:
          return a2(o3, r3), null;
      }
    }({ elementToRender: r2, domElement: c2, reactDom: d(e2), renderType: f(e2) });
    e2.domElements[t2.name] = c2, e2.renderResults[t2.name] = u2;
  });
}
function l(e2, t2) {
  return new Promise(function(n2) {
    e2.unmountResolves[t2.name] = n2;
    var o2 = e2.renderResults[t2.name];
    o2 && o2.unmount ? o2.unmount() : d(e2).unmountComponentAtNode(e2.domElements[t2.name]), delete e2.domElements[t2.name], delete e2.renderResults[t2.name];
  });
}
function m(e2, t2) {
  return new Promise(function(n2) {
    e2.updateResolves[t2.name] || (e2.updateResolves[t2.name] = []), e2.updateResolves[t2.name].push(n2);
    var o2 = y(e2, t2, null), r2 = e2.renderResults[t2.name];
    if (r2 && r2.render)
      r2.render(o2);
    else {
      var c2 = a(e2, t2)();
      d(e2).render(o2, c2);
    }
  });
}
function d(e2) {
  return e2.ReactDOMClient || e2.ReactDOM;
}
function f(e2) {
  return "function" == typeof e2.renderType ? e2.renderType() : e2.renderType;
}
function y(e2, n2, o2) {
  var r2 = e2.React.createElement(e2.rootComponent, n2), a2 = c ? e2.React.createElement(c.Provider, { value: n2 }, r2) : r2;
  return (e2.errorBoundary || n2.errorBoundary || e2.errorBoundaryClass || n2.errorBoundaryClass) && (e2.errorBoundaryClass = e2.errorBoundaryClass || n2.errorBoundaryClass || function(e3, t2) {
    function n3(t3) {
      e3.React.Component.apply(this, arguments), this.state = { caughtError: null, caughtErrorInfo: null }, n3.displayName = "SingleSpaReactErrorBoundary(".concat(t3.name, ")");
    }
    return n3.prototype = Object.create(e3.React.Component.prototype), n3.prototype.render = function() {
      return this.state.caughtError ? (e3.errorBoundary || t2.errorBoundary)(this.state.caughtError, this.state.caughtErrorInfo, this.props) : this.props.children;
    }, n3.prototype.componentDidCatch = function(e4, t3) {
      this.setState({ caughtError: e4, caughtErrorInfo: t3 });
    }, n3;
  }(e2, n2), a2 = e2.React.createElement(e2.errorBoundaryClass, n2, a2)), a2 = e2.React.createElement(e2.SingleSpaRoot, t(t({}, n2), {}, { mountFinished: o2, updateFinished: function() {
    e2.updateResolves[n2.name] && (e2.updateResolves[n2.name].forEach(function(e3) {
      return e3();
    }), delete e2.updateResolves[n2.name]);
  }, unmountFinished: function() {
    e2.unmountResolves[n2.name] && (e2.unmountResolves[n2.name](), delete e2.unmountResolves[n2.name]);
  } }), a2);
}
export {
  c as SingleSpaContext,
  i as default
};
//# sourceMappingURL=single-spa-react.js.map
